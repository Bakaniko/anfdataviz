# ------------------------
# Des données sur l'Europe
# ------------------------
library("eurostat")
# PIB
var <- "nama_10r_3gdp"
gdp <- get_eurostat(var,select_time=2015)
gdp <- as.data.frame(gdp)
gdp <- gdp[gdp$unit== "MIO_EUR",]
gdp <- gdp[,c("geo","values")]
colnames(gdp) <- c("id","gdp2016")
View(gdp)
# POPULATION
var <- "demo_r_pjangrp3"
pop <- get_eurostat(var,select_time=2015)
pop <- as.data.frame(pop)
pop <- pop[pop$sex == "T",]
pop <- pop[pop$age == "TOTAL",]
pop <- pop[,c("geo","values")]
colnames(pop) <- c("id","pop2016")
# -------
# Merge
# -------
regions
regions <- merge(regions, pop, by = "id", all.x= T)
regions <- merge(regions, gdp, by = "id", all.x = T)
View(regions)
# -------
# Cartes
# -------
title <- "People at risk of poverty or social exclusion by NUTS 2"
getwd()
# *****************************************
# ** Exercice 4 : cartographier le Monde **
# *****************************************
getwd()
# *****************************************
# ** Exercice 4 : cartographier le Monde **
# *****************************************
# Charger les packages
library("sf")
# -----------------------------------------
# Import et configuration du fond de carte
# -----------------------------------------
# méthode 1 : à la main (après téléchargement sur le site Natural Earth)
countries <- st_read(dsn = "data/world/naturalearth/ne_110m_admin_0_countries.shp", stringsAsFactors = F)
# Méthode 2 : directement via R
url <- "https://www.naturalearthdata.com/http//www.naturalearthdata.com/download/110m/cultural/ne_110m_admin_0_countries.zip"
download.file(url = url, destfile = "data/download/countries.zip")
list.files("data/download")
unzip("data/download/countries.zip", exdir = "data/download", unzip = "internal")
list.files("data/download")
file.remove("data/download/countries.zip")
list.files("data/download")
countries <- st_read(dsn = "data/download/ne_110m_admin_0_countries.shp", stringsAsFactors = F)
# Méthode 3 : grace au package rnaturalearth
library("rnaturalearth")
countries <- ne_countries(scale = 50, type = "countries", continent = NULL,
country = NULL, geounit = NULL, sovereignty = NULL,
returnclass = "sf")
# Affichage
plot(st_geometry(countries))
# On ne garde que les champs utiles
head(countries)
countries <- countries[,c("adm0_a3", "admin", "geometry")]
colnames(countries) <- c("id","name","geometry")
head(countries)
# Supprimer l'antarctique
countries <- countries[countries$id != "ATA",]
plot(st_geometry(countries))
# Supprimer les lignes vides
countries <- countries[!is.na(countries$id),]
# --------------------------------
# Import des données attributaires
# --------------------------------
# Esperance de vie (source : Banque mondiale)
library("readxl")
file <-"data/world/worldbank/API_SP.DYN.LE00.IN_DS2_en_excel_v2_10081535.xls"
sheet <- "Data"
lifexp <- data.frame(read_excel(file, skip = 3, sheet = sheet))
lifexp <- lifexp[,c("Country.Code","Country.Name","X2016")]
colnames(lifexp) <- c("id","name","lifexp2016")
class()
lifexp$lifexp2016 <- as.numeric(as.character(lifexp$lifexp2016))
# Indice de deveoppement humain (source : Human Development Report)
file <-"data/world/hdr/Human Development Index (HDI).csv"
hdi <- read.csv2(file = file, sep = ",",skip = 1)
head(hdi)
hdi <- hdi[,c("Country","X2016")]
library("countrycode")
hdi$id <- countrycode(hdi$Country, 'country.name', 'iso3c')
hdi <- hdi[,c("id","Country","X2016")]
colnames(hdi) <- c("id","name","hdi2016")
hdi$hdi2016 <- as.numeric(as.character(hdi$hdi2016))
class(hdi$hdi2016)
library("cartography")
countries <- st_transform(countries, "+proj=cea +lon_0=0 +lat_ts=45 +x_0=0 +y_0=0 +ellps=WGS84 +units=m +no_defs ")
plot(st_geometry(countries))
countries <- merge(countries, lifexp, by="id", all.x=TRUE)
countries <- merge(countries, hdi, by="id", all.x=TRUE)
countries <- countries[,c("id","name.x","lifexp2016","hdi2016","geometry")]
colnames(countries)[2] <- "name"
# analyse de la distribution
var <- countries$hdi2016
hist(countries$hdi2016, probability = TRUE, nclass = 30)
breaks <- getBreaks(v = var, nclass = 6, method = "quantile")
cols <- carto.pal(pal1="blue.pal", n1 = 3, pal2 = "orange.pal", n2 = 3, middle = FALSE, transparency = FALSE)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
borders <- getBorders(countries)
outer <- getOuterBorders(x = countries, res = 1000000, width = 200000)
outer <- getOuterBorders(x = countries, res = 80000, width = 200000)
plot(outer, add=T, col="black",lwd=2)
outer <- getOuterBorders(x = countries, res = 80000)
plot(outer, add=T, col="black",lwd=2)
outer <- getOuterBorders(x = countries, res = 80000, width=500000)
plot(outer, add=T, col="black",lwd=2)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
plot(outer, add=T, col="black",lwd=2)
outer <- getOuterBorders(x = countries, res = 800000, width=500000)
outer <- getOuterBorders(x = countries, res = 100000, width=500000)
outer <- getOuterBorders(x = countries, res = 500000, width=500000)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
plot(outer, add=T, col="black",lwd=2)
outer <- getOuterBorders(x = countries, res = 200000, width=500000)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
plot(outer, add=T, col="black",lwd=2)
outer <- getOuterBorders(x = countries, res = 100000, width=500000)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
plot(outer, add=T, col="black",lwd=2)
b <- rbind(borders,outer)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.2, sizemin = 0.2,
sizemax = 5, type = "rel",
legend.title.txt = "Discontinuities\n(relative difference)",
legend.pos = "bottomleft", add=TRUE)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.3, sizemin = 0.2,
sizemax = 5, type = "rel",
legend.title.txt = "Discontinuities\n(relative difference)",
legend.pos = "bottomleft", add=TRUE)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.3, sizemin = 0.2,
sizemax = 5, type = "abs",
legend.title.txt = "Discontinuities\n(relative difference)",
legend.pos = "bottomleft", add=TRUE)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "left",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.25, sizemin = 0.2,
sizemax = 5, type = "abs",
legend.title.txt = "Discontinuities\n(relative difference)",
legend.pos = "bottomleft", add=TRUE)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "topleft",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
b <- rbind(borders,outer)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.25, sizemin = 0.2,
sizemax = 5, type = "abs",
legend.title.txt = "Discontinuities\n(relative difference)",
legend.pos = "bottomleft", add=TRUE)
layoutLayer(extent = countries,
bg="#EEEEEE",
title = "Indice de développement humain en 2016",
scale = NULL,
sources = "Human development Report, 2018",
author = "les serial mappers"
)
choroLayer(x = countries,
var = "hdi2016",
breaks = breaks,
col = cols,
border = "white",
lwd=0.2,
add = TRUE,
legend.pos = "topleft",
legend.title.txt = "IDH, 2016",
legend.values.rnd = 2)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.25, sizemin = 0.2,
sizemax = 8, type = "abs",
legend.title.txt = "Discontinuities\n(relative difference)",
legend.pos = "bottomleft", add=TRUE)
discLayer(x = b, df = countries,
var = "hdi2016", col="black", nclass=4,
method="quantile", threshold = 0.25, sizemin = 0.2,
sizemax = 8, type = "abs",
legend.title.txt = "Discontinuities\nabsolues",
legend.pos = "bottomleft", add=TRUE)
install.packages("rmdformats")
---
title: "Cartographie et visualisation sous R"
date: "`r Sys.Date()`"
author: Nicolas Lambert, Ronan Ysebaert
output:
rmdformats::readthedown:
self_contained: FALSE
thumbnails: false
lightbox: true
gallery: true
highlight: tango
---
Cette formation de 3 heures porte sur la visualisation de données géographiques sous R. Y sont abordées
les traitements de SIG de base, la cartographie thématique de base (cartes en figurés proportionnels, cartes
choroplèthes, cartes de typologie) et des cartes reposant sur des techniques plus avancées comme les cartes
sur grille ou les cartes de discontinuité.
Sont ici princiapelement utilisés les packages sf (manipulation de données spatiales) et cartography (cartographie
thématique). Chaque exemple propose une chaine de traitement depuis le chargement des données, leur mise en forme,
jusqu'à la mobilisation de méthodes adaptées permettant de répondre à des questions spatiales.
Les exemples proposés sont basés sur différentes échelles, du local (région Occitanie) en passant par l'Europe et
le Monde.
# Pré-réquis
## Les packages
Sont décrits ici la version de R avec laquelle a été produit ce support de formation ainsi que les packages qui seront
utilisés dans la formation et leur version respective.
```{r}
library(devtools)
session_info(pkgs = c("cartography","sf"), include_base = FALSE)
```
Pour exécuter les programmes proposés par la formation, [installez / mettez à jour R](https://www.r-project.org/) (version 3.5.1 minimum), [R Studio](https://www.rstudio.com/). Lancez ensuite R studio et installez les packages au moyen des commandes suivantes (prévoir bien 10 minutes)
```{r echo = TRUE}
# install.packages("sf")
# install.packages("devtools")
# install.packages("cartography")
# install.packages("countrycode")
# install.packages("readxl")
# install.packages("animation")
# install.packages("rmapshaper")
# install.packages("rnaturalearthdata")
# install.packages("rnaturalearth")
# install.packages("cartogram")
# install.packages("reshape2")
# install.packages("eurostat")
```
* Le package **sf** est un package qui permet d'importer, gérer et transformer des données géographiques (gestion des projections, opérations SIG).
* Le package **cartography** permet de créer et intégrer des cartes thématiques dans sa chaine de traitement en R. Il permet des représentations cartographiques tels que les cartes en symboles proportionnels, des cartes choroplèthes, des typologies, des cartes de flux ou des cartes de discontinuité. Il offre également des fonctions qui permettent d'améliorer la réalisation de la carte, comme des palettes de couleur, des éléments d'habillage (échelle, flèche du nord, titre, légende...), d'y rattacher des labels ou d'accéder à des APIs cartographiques.
* Le package...
## Téléchargez les données
Téléchargez les données sur la page github. Décompressez les données sur votre espace de travail.
Lien github à ajouter
# Exo 1 - Prise en main
## Commandes de base
Définissez votre répertoire de travail.
```{r, eval=F}
setwd("Votre_repertoire_de_travail")
```
```{r, eval=T, echo=FALSE}
# setwd("C:/MyCore/ANF2018 - R geoviz")
setwd("/home/nlambert/ownCloud/ANF2018 - R geoviz")
```
Consulter le contenu. Et regarder ce qu'il y a dans le répertoire "data"
```{r, eval=T}
list.files()
list.files("data")
```
Import d'une couche SIG dans R avec le package sf. Pacakge basé sur GEOS
(Geometry Engine Open Source) et GDAL (Geospatial Data Abstraction Library).
```{r, eval=T}
library("sf")
communes <- st_read(dsn = "data/Hérault/communes.shp", stringsAsFactors = F)
```
Voir la table atributaire
```{r, eval=T}
communes
head(communes)
View(communes)
```
L'instruction plot permet d'afficher la couche.
L'instruction st_geometry permet d'accéder à la variable définissant les géométries.
```{r, eval=T}
plot(st_geometry(communes))
```
Afficher la couche avec des parametres graphiques
```{r, eval=T}
plot(st_geometry(communes), col="#aec8f2", border="darkblue", lwd=1)
```
## Introduction au SIG avec R / Manipuler les informations spatiales
Nous cherchons à identifier les communes qui ont une partie de leur territoire
situé à moins de 20 km du centre de Sete.
Nous commencçons par extraire la commune de Sète.
```{r, eval=T}
macommune <- "SETE"
monpoly <- communes[communes$NOM_COMM == macommune,]
plot(st_geometry(communes), col="#aec8f2", border="darkblue", lwd=1)
plot(st_geometry(monpoly), col="red", border="purple", lwd=1, add=T)
```
Extraitre le centroide de la commune de Sete.
```{r, eval=T}
moncentre <- st_centroid(x = monpoly)
plot(st_geometry(communes), col="#aec8f2", border="darkblue", lwd=1)
plot(st_geometry(monpoly), col="red", border="purple", lwd=1, add=T)
plot(st_geometry(moncentre), pch=20, col="black", cex=2, add=T)
```
Calculer une zone tampon
```{r, eval=T}
mydist <- 20000
buff <- st_buffer(x = st_geometry(moncentre), dist=mydist)
plot(st_geometry(communes), col="#aec8f2", border="darkblue", lwd=1)
plot(st_geometry(monpoly), col="red", border="purple", lwd=1, add=T)
plot(st_geometry(moncentre), pch=20, col="black", cex=2, add=T)
plot(buff, col=NA, border="black", lty=2,add=T)
```
Récupérer la liste des communes
```{r, eval=T}
communes$buff <- st_intersects(st_geometry(communes), st_geometry(buff), sparse = FALSE)
head(communes)
```
Récupérer le nombre de communes à moins de 20 km
```{r, eval=T}
nb <- dim(communes[communes$buff == T,])
nb[1]
```
Extraction et affichage des communes
```{r, eval=T}
communes20km <- communes[communes$buff == TRUE,]
plot(st_geometry(communes), col="#aec8f2", border="darkblue", lwd=1)
plot(st_geometry(monpoly), col="red", border="purple", lwd=1, add=T)
plot(st_geometry(moncentre), pch=20, col="black", cex=2, add=T)
plot(buff, col=NA, border="black", lty=2,add=T)
plot(st_geometry(communes20km), col=NA, lwd=2, border="red", add=T)
```
Ajout d'un titre
```{r, eval=T}
plot(st_geometry(communes), col="#aec8f2", border="darkblue", lwd=1)
plot(st_geometry(monpoly), col="red", border="purple", lwd=1, add=T)
plot(st_geometry(moncentre), pch=20, col="black", cex=2, add=T)
plot(buff, col=NA, border="black", lty=2,add=T)
plot(st_geometry(communes20km), col=NA, lwd=2, border="red", add=T)
montitre <- paste0("Il y a ", nb[1], " communes situées à moins de ", mydist/1000, "km de ",tolower(macommune))
title(montitre)
```
Export (si besoin)
```{r, eval=F, echo=T}
st_write(obj = communes20km, dsn = "outputs/resultat.shp")
```
## A vous de jouer !
Reproduisez cette procédure avec la commune et la distance de votre choix.
Pour accéder au listing des communes d'Hérault
```{r, eval=F}
communes$NOM_COMM
```
# Exo 2 - Cartes en figurés proportionnels
## Objectifs :
* Thématique : Réaliser une carte des catégories Socio professionnelles.
* Espace d'étude : Occitanie, communes
* Visualisation associée : carte en figurés proportionnels (+ cartogrammes de Dorling)
* packages utilisés : sf, cartography, cartogram, readxl
Créer un nouveau fichier "Exo2.R".
## Chargement et préparation des données
Pour bien commencer, il est fondamental de jeter un oeil au fichier d'entrée
pour comprendre son organisation et savoir comment l'importer sous R.
Ouvrez le fichier data/France/INSEE/pop-act2554-csp-cd-6814.xls
Nous nous intéressons ici à l'onglet "COM_2014".
```{r}
library("sf")
library("readxl")
```
## Visualisation : carte en figuré proportionnel
```{r}
library("cartography")
```
variable visuelle taille adaptée aux caractères quantitatifs absolus.
## Visualisation : carte combinant figuré proportionnel et typologie
variable visuelle taille + variable visuelle couleur
## Visualisation : cartogramme de Dorling
```{r}
library("cartogram")
```
# Exo 3 -
## Chargement des packages nécessaires
